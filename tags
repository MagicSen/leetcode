!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
BFS	.\binary_tree_maximum_path_sum.cpp	/^	void BFS(TreeNode *root){$/;"	f	class:Solution
DFS	.\binary_tree_maximum_path_sum.cpp	/^	void DFS(TreeNode *root){$/;"	f	class:Solution
DLR	.\binary_tree_maximum_path_sum.cpp	/^	void DLR(TreeNode *root){$/;"	f	class:Solution
Interval	.\insert_interval.cpp	/^	Interval() : start(0), end(0) {}$/;"	f	struct:Interval
Interval	.\insert_interval.cpp	/^	Interval(int s, int e) : start(s), end(e) {}$/;"	f	struct:Interval
Interval	.\insert_interval.cpp	/^struct Interval {$/;"	s	file:
LDR	.\binary_tree_maximum_path_sum.cpp	/^	void LDR(TreeNode *root){$/;"	f	class:Solution
LRD	.\binary_tree_maximum_path_sum.cpp	/^	void LRD(TreeNode *root){$/;"	f	class:Solution
LRUCache	.\lru_cache.cpp	/^		LRUCache(int capacity) {$/;"	f	class:LRUCache
LRUCache	.\lru_cache.cpp	/^class LRUCache{$/;"	c	file:
ListNode	.\insertion_sort_list.cpp	/^	ListNode(int x) : val(x), next(NULL) {}$/;"	f	struct:ListNode
ListNode	.\insertion_sort_list.cpp	/^struct ListNode {$/;"	s	file:
ListNode	.\linked_list_cicle_1.cpp	/^	ListNode(int x) : val(x), next(NULL) {}$/;"	f	struct:ListNode
ListNode	.\linked_list_cicle_1.cpp	/^struct ListNode {$/;"	s	file:
ListNode	.\linked_list_cicle_2.cpp	/^	ListNode(int x) : val(x), next(NULL) {}$/;"	f	struct:ListNode
ListNode	.\linked_list_cicle_2.cpp	/^struct ListNode {$/;"	s	file:
ListNode	.\remove_duplicates_from_sorted_list.cpp	/^    ListNode(int x) : val(x), next(NULL) {}$/;"	f	struct:ListNode
ListNode	.\remove_duplicates_from_sorted_list.cpp	/^struct ListNode{$/;"	s	file:
ListNode	.\remove_duplicates_from_sorted_list2.cpp	/^    ListNode(int x) : val(x), next(NULL) {}$/;"	f	struct:ListNode
ListNode	.\remove_duplicates_from_sorted_list2.cpp	/^struct ListNode{$/;"	s	file:
ListNode	.\reorder_list.cpp	/^	ListNode(int x) : val(x), next(NULL) {}$/;"	f	struct:ListNode
ListNode	.\reorder_list.cpp	/^struct ListNode {$/;"	s	file:
ListNode	.\sort_list.cpp	/^	ListNode(int x) : val(x), next(NULL) {}$/;"	f	struct:ListNode
ListNode	.\sort_list.cpp	/^struct ListNode {$/;"	s	file:
Point	.\max_points_on_a_line.cpp	/^	Point(int a, int b) : x(a), y(b) {}$/;"	f	struct:Point
Point	.\max_points_on_a_line.cpp	/^ 	Point() : x(0), y(0) {}$/;"	f	struct:Point
Point	.\max_points_on_a_line.cpp	/^struct Point {$/;"	s	file:
RandomListNode	.\copy_list_with_random_pointer.cpp	/^	RandomListNode(int x) : label(x), next(NULL), random(NULL) {}$/;"	f	struct:RandomListNode
RandomListNode	.\copy_list_with_random_pointer.cpp	/^struct RandomListNode {$/;"	s	file:
Solution	.\anagrams.cpp	/^class Solution {$/;"	c	file:
Solution	.\binary_tree_maximum_path_sum.cpp	/^class Solution {$/;"	c	file:
Solution	.\binary_tree_postorder_traversal.cpp	/^class Solution {$/;"	c	file:
Solution	.\binary_tree_preoorder_traversal.cpp	/^class Solution {$/;"	c	file:
Solution	.\candy.cpp	/^class Solution {$/;"	c	file:
Solution	.\climbing_stairs.cpp	/^class Solution {$/;"	c	file:
Solution	.\clone_graph.cpp	/^class Solution {$/;"	c	file:
Solution	.\combination_sum.cpp	/^class Solution {$/;"	c	file:
Solution	.\combination_sum2.cpp	/^class Solution {$/;"	c	file:
Solution	.\combinations.cpp	/^class Solution {$/;"	c	file:
Solution	.\construct_binary_tree.cpp	/^class Solution {$/;"	c	file:
Solution	.\copy_list_with_random_pointer.cpp	/^class Solution {$/;"	c	file:
Solution	.\distinct_subsequences.cpp	/^class Solution {$/;"	c	file:
Solution	.\evaluate_reverse_polish_notation.cpp	/^class Solution {$/;"	c	file:
Solution	.\first_missing_positive.cpp	/^class Solution {$/;"	c	file:
Solution	.\gas_station.cpp	/^class Solution {$/;"	c	file:
Solution	.\generate_parentheses.cpp	/^class Solution {$/;"	c	file:
Solution	.\gray_code.cpp	/^class Solution {$/;"	c	file:
Solution	.\insert_interval.cpp	/^class Solution {$/;"	c	file:
Solution	.\insertion_sort_list.cpp	/^class Solution {$/;"	c	file:
Solution	.\integer_to_roman.cpp	/^class Solution {$/;"	c	file:
Solution	.\largest_rectangle_in_histogram.cpp	/^class Solution {$/;"	c	file:
Solution	.\letter_combinations_of_a_phone_number.cpp	/^class Solution {$/;"	c	file:
Solution	.\linked_list_cicle_1.cpp	/^class Solution {$/;"	c	file:
Solution	.\linked_list_cicle_2.cpp	/^class Solution {$/;"	c	file:
Solution	.\longest_consecutive_sequence.cpp	/^class Solution {$/;"	c	file:
Solution	.\max_points_on_a_line.cpp	/^class Solution {$/;"	c	file:
Solution	.\maximum_subarray.cpp	/^class Solution {$/;"	c	file:
Solution	.\median_of_two_sorted.cpp	/^class Solution {$/;"	c	file:
Solution	.\merge_sorted_array.cpp	/^class Solution {$/;"	c	file:
Solution	.\n_queens.cpp	/^class Solution {$/;"	c	file:
Solution	.\n_queens2.cpp	/^class Solution {$/;"	c	file:
Solution	.\palidrome_partitioning.cpp	/^class Solution {$/;"	c	file:
Solution	.\palidrome_partitioning2.cpp	/^class Solution {$/;"	c	file:
Solution	.\populating_next_right_pointers_in_each_node.cpp	/^class Solution {$/;"	c	file:
Solution	.\pow.cpp	/^class Solution {$/;"	c	file:
Solution	.\remove_duplicates_from_sorted_list.cpp	/^class Solution {$/;"	c	file:
Solution	.\remove_duplicates_from_sorted_list2.cpp	/^class Solution {$/;"	c	file:
Solution	.\reorder_list.cpp	/^class Solution {$/;"	c	file:
Solution	.\reverse_words_in_a_string.cpp	/^class Solution{$/;"	c	file:
Solution	.\search_in_rotated_sorted.cpp	/^class Solution {$/;"	c	file:
Solution	.\search_insert_position.cpp	/^class Solution {$/;"	c	file:
Solution	.\single_number_1.cpp	/^class Solution {$/;"	c	file:
Solution	.\single_number_2.cpp	/^class Solution {$/;"	c	file:
Solution	.\sort_list.cpp	/^class Solution {$/;"	c	file:
Solution	.\sqrt.cpp	/^class Solution {$/;"	c	file:
Solution	.\sum_root_to_left_numbers.cpp	/^class Solution {$/;"	c	file:
Solution	.\text_justification.cpp	/^class Solution {$/;"	c	file:
Solution	.\two_sum.cpp	/^class Solution {$/;"	c	file:
Solution	.\unique_path.cpp	/^	Solution(){$/;"	f	class:Solution
Solution	.\unique_path.cpp	/^class Solution {$/;"	c	file:
Solution	.\valid_palindrome.cpp	/^class Solution {$/;"	c	file:
Solution	.\wildcard_matching.cpp	/^class Solution {$/;"	c	file:
Solution	.\word_break_1.cpp	/^class Solution {$/;"	c	file:
Solution	.\word_break_2.cpp	/^class Solution {$/;"	c	file:
TreeLinkNode	.\populating_next_right_pointers_in_each_node.cpp	/^	TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {}$/;"	f	struct:TreeLinkNode
TreeLinkNode	.\populating_next_right_pointers_in_each_node.cpp	/^struct TreeLinkNode {$/;"	s	file:
TreeNode	.\binary_tree_maximum_path_sum.cpp	/^	TreeNode(int x) : val(x), left(NULL), right(NULL) {}$/;"	f	struct:TreeNode
TreeNode	.\binary_tree_maximum_path_sum.cpp	/^struct TreeNode {$/;"	s	file:
TreeNode	.\binary_tree_postorder_traversal.cpp	/^	TreeNode(int x) : val(x), left(NULL), right(NULL) {}$/;"	f	struct:TreeNode
TreeNode	.\binary_tree_postorder_traversal.cpp	/^struct TreeNode {$/;"	s	file:
TreeNode	.\binary_tree_preoorder_traversal.cpp	/^	TreeNode(int x) : val(x), left(NULL), right(NULL) {}$/;"	f	struct:TreeNode
TreeNode	.\binary_tree_preoorder_traversal.cpp	/^struct TreeNode {$/;"	s	file:
TreeNode	.\construct_binary_tree.cpp	/^	TreeNode(int x) : val(x), left(NULL), right(NULL) {}$/;"	f	struct:TreeNode
TreeNode	.\construct_binary_tree.cpp	/^struct TreeNode {$/;"	s	file:
TreeNode	.\sum_root_to_left_numbers.cpp	/^	TreeNode(int x) : val(x), left(NULL), right(NULL) {}$/;"	f	struct:TreeNode
TreeNode	.\sum_root_to_left_numbers.cpp	/^struct TreeNode {$/;"	s	file:
UndirectedGraphNode	.\clone_graph.cpp	/^	UndirectedGraphNode(int x) : label(x) {};$/;"	f	struct:UndirectedGraphNode
UndirectedGraphNode	.\clone_graph.cpp	/^struct UndirectedGraphNode {$/;"	s	file:
addPalindrome	.\palidrome_partitioning.cpp	/^		void addPalindrome(string &s, int start, vector<string> &partition_temp, vector<vector<string>> &result){$/;"	f	class:Solution
anagrams	.\anagrams.cpp	/^	vector<string> anagrams(vector<string> &strs) {$/;"	f	class:Solution
binary_search	.\search_insert_position.cpp	/^	int binary_search(int A[], int hi, int lo, int target, int n){$/;"	f	class:Solution
buildTree	.\construct_binary_tree.cpp	/^		TreeNode *buildTree(vector<int> &preorder, int pre_begin, int pre_end, vector<int> &inorder, int ino_begin, int ino_end) {$/;"	f	class:Solution
buildTree	.\construct_binary_tree.cpp	/^		TreeNode *buildTree(vector<int> &preorder, vector<int> &inorder) {$/;"	f	class:Solution
canCompleteCircuit	.\gas_station.cpp	/^		int canCompleteCircuit(vector<int> &gas, vector<int> &cost) {$/;"	f	class:Solution
candy	.\candy.cpp	/^		int candy(vector<int> &ratings) {$/;"	f	class:Solution
capacity	.\lru_cache.cpp	/^		int capacity;$/;"	m	class:LRUCache	file:
climbStairs	.\climbing_stairs.cpp	/^    int climbStairs(int n) {$/;"	f	class:Solution
cloneGraph	.\clone_graph.cpp	/^		UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {$/;"	f	class:Solution
combinationSum	.\combination_sum.cpp	/^	vector<vector<int> > combinationSum(vector<int> &candidates, int target) {$/;"	f	class:Solution
combinationSum	.\combination_sum2.cpp	/^	vector<vector<int> > combinationSum(vector<int> &candidates, int target) {$/;"	f	class:Solution
combine	.\combinations.cpp	/^	vector<vector<int> > combine(int n, int k) {$/;"	f	class:Solution
connect	.\populating_next_right_pointers_in_each_node.cpp	/^	void connect(TreeLinkNode *root) {$/;"	f	class:Solution
copyRandomList	.\copy_list_with_random_pointer.cpp	/^		RandomListNode *copyRandomList(RandomListNode *head) {$/;"	f	class:Solution
createTree	.\binary_tree_maximum_path_sum.cpp	/^	TreeNode *createTree(vector<int> value){$/;"	f	class:Solution
deleteDuplicates	.\remove_duplicates_from_sorted_list.cpp	/^	ListNode *deleteDuplicates(ListNode *head) {$/;"	f	class:Solution
deleteDuplicates	.\remove_duplicates_from_sorted_list2.cpp	/^	ListNode *deleteDuplicates(ListNode *head) {$/;"	f	class:Solution
detectCycle	.\linked_list_cicle_2.cpp	/^		ListNode *detectCycle(ListNode *head) {$/;"	f	class:Solution
dict	.\anagrams.cpp	/^	set<string> dict;$/;"	m	class:Solution	file:
dict	.\distinct_subsequences.cpp	/^	map<pair<string, string>, int> dict;$/;"	m	class:Solution	file:
dictionary	.\climbing_stairs.cpp	/^	map<int, int> dictionary;$/;"	m	class:Solution	file:
end	.\insert_interval.cpp	/^	int end;$/;"	m	struct:Interval	file:
evalRPN	.\evaluate_reverse_polish_notation.cpp	/^    	int evalRPN(vector<string> &tokens) {$/;"	f	class:Solution
findMedianSortedArrays	.\median_of_two_sorted.cpp	/^	double findMedianSortedArrays(int A[], int m, int B[], int n) {$/;"	f	class:Solution
firstMissingPositive	.\first_missing_positive.cpp	/^                int firstMissingPositive(int A[], int n) {$/;"	f	class:Solution
fullJustify	.\text_justification.cpp	/^		vector<string> fullJustify(vector<string> &words, int L) {$/;"	f	class:Solution
generateParenthesis	.\generate_parentheses.cpp	/^	vector<string> generateParenthesis(int n) {$/;"	f	class:Solution
get	.\lru_cache.cpp	/^		int get(int key) {$/;"	f	class:LRUCache
getKth	.\median_of_two_sorted.cpp	/^	int getKth(int A[], int m, int B[], int n, int k){$/;"	f	class:Solution
get_a_b	.\max_points_on_a_line.cpp	/^	void get_a_b(const Point &p1, const Point &p2, double &a, double &b){$/;"	f	class:Solution
grayCode	.\gray_code.cpp	/^		vector<int> grayCode(int n) {$/;"	f	class:Solution
hasCycle	.\linked_list_cicle_1.cpp	/^		bool hasCycle(ListNode *head) {$/;"	f	class:Solution
insert	.\insert_interval.cpp	/^		vector<Interval> insert(vector<Interval> &intervals, Interval newInterval) {$/;"	f	class:Solution
insert_after	.\reorder_list.cpp	/^		void insert_after(ListNode *p1, ListNode *p2)$/;"	f	class:Solution
insertionSortList	.\insertion_sort_list.cpp	/^		ListNode *insertionSortList(ListNode *head) {$/;"	f	class:Solution
intToRoman	.\integer_to_roman.cpp	/^	string intToRoman(int num) {$/;"	f	class:Solution
isEqual	.\combination_sum.cpp	/^	int isEqual(vector<int> &candidates, vector<int> choosen_num, int row, int target){$/;"	f	class:Solution
isEqual	.\combination_sum2.cpp	/^	int isEqual(vector<int> &candidates, vector<int> choosen_num, int row, int target){$/;"	f	class:Solution
isMatch	.\wildcard_matching.cpp	/^		bool isMatch(const char *s, const char *p) {$/;"	f	class:Solution
isNumber	.\evaluate_reverse_polish_notation.cpp	/^	bool isNumber(const string &s)	$/;"	f	class:Solution
isPalindrome	.\valid_palindrome.cpp	/^		bool isPalindrome(string s) {$/;"	f	class:Solution
isValid	.\n_queens.cpp	/^	bool isValid(vector<int> col, int row, int col_number){$/;"	f	class:Solution
isValid	.\n_queens2.cpp	/^	bool isValid(vector<int> col, int row, int col_number){$/;"	f	class:Solution
is_in_line	.\max_points_on_a_line.cpp	/^	bool is_in_line(const Point p, const double &a, const double &b){$/;"	f	class:Solution
ispalidrome	.\palidrome_partitioning.cpp	/^		bool ispalidrome(const string str, int begin, int end){$/;"	f	class:Solution
ispalidrome	.\palidrome_partitioning2.cpp	/^		bool ispalidrome(const string str, int begin, int end){$/;"	f	class:Solution
isvalid	.\valid_palindrome.cpp	/^		bool isvalid(char ch)$/;"	f	class:Solution
label	.\clone_graph.cpp	/^	int label;$/;"	m	struct:UndirectedGraphNode	file:
label	.\copy_list_with_random_pointer.cpp	/^	int label;$/;"	m	struct:RandomListNode	file:
largestRectangleArea	.\largest_rectangle_in_histogram.cpp	/^		int largestRectangleArea(vector<int> &height) {$/;"	f	class:Solution
left	.\binary_tree_maximum_path_sum.cpp	/^	TreeNode *left;$/;"	m	struct:TreeNode	file:
left	.\binary_tree_postorder_traversal.cpp	/^	TreeNode *left;$/;"	m	struct:TreeNode	file:
left	.\binary_tree_preoorder_traversal.cpp	/^	TreeNode *left;$/;"	m	struct:TreeNode	file:
left	.\construct_binary_tree.cpp	/^	TreeNode *left;$/;"	m	struct:TreeNode	file:
left	.\populating_next_right_pointers_in_each_node.cpp	/^	TreeLinkNode *left, *right, *next;$/;"	m	struct:TreeLinkNode	file:
left	.\sum_root_to_left_numbers.cpp	/^	TreeNode *left;$/;"	m	struct:TreeNode	file:
less_equal_bigger	.\single_number_1.cpp	/^		int less_equal_bigger(int A[], int lo, int hi)	$/;"	f	class:Solution
less_equal_bigger	.\single_number_2.cpp	/^		int less_equal_bigger(int A[], int lo, int hi)	$/;"	f	class:Solution
letterCombinations	.\letter_combinations_of_a_phone_number.cpp	/^	vector<string> letterCombinations(string digits) {$/;"	f	class:Solution
list_length	.\lru_cache.cpp	/^		int list_length;$/;"	m	class:LRUCache	file:
longestConsecutive	.\longest_consecutive_sequence.cpp	/^		int longestConsecutive(vector<int> &num) {$/;"	f	class:Solution
main	.\anagrams.cpp	/^int main()$/;"	f
main	.\binary_tree_maximum_path_sum.cpp	/^int main()$/;"	f
main	.\binary_tree_postorder_traversal.cpp	/^int main()$/;"	f
main	.\binary_tree_preoorder_traversal.cpp	/^int main()$/;"	f
main	.\candy.cpp	/^int main()$/;"	f
main	.\climbing_stairs.cpp	/^int main()$/;"	f
main	.\clone_graph.cpp	/^int main()$/;"	f
main	.\combination_sum.cpp	/^int main()$/;"	f
main	.\combination_sum2.cpp	/^int main()$/;"	f
main	.\combinations.cpp	/^int main()$/;"	f
main	.\construct_binary_tree.cpp	/^int main()$/;"	f
main	.\copy_list_with_random_pointer.cpp	/^int main()$/;"	f
main	.\distinct_subsequences.cpp	/^int main()$/;"	f
main	.\evaluate_reverse_polish_notation.cpp	/^int main()$/;"	f
main	.\gas_station.cpp	/^int main()$/;"	f
main	.\generate_parentheses.cpp	/^int main()$/;"	f
main	.\gray_code.cpp	/^int main()$/;"	f
main	.\insert_interval.cpp	/^int main()$/;"	f
main	.\insertion_sort_list.cpp	/^int main()$/;"	f
main	.\integer_to_roman.cpp	/^int main()$/;"	f
main	.\largest_rectangle_in_histogram.cpp	/^int main()$/;"	f
main	.\letter_combinations_of_a_phone_number.cpp	/^int main(){$/;"	f
main	.\linked_list_cicle_1.cpp	/^int main()$/;"	f
main	.\linked_list_cicle_2.cpp	/^int main()$/;"	f
main	.\longest_consecutive_sequence.cpp	/^int main()$/;"	f
main	.\lru_cache.cpp	/^int main()$/;"	f
main	.\max_points_on_a_line.cpp	/^int main()$/;"	f
main	.\maximum_subarray.cpp	/^int main()$/;"	f
main	.\median_of_two_sorted.cpp	/^int main()$/;"	f
main	.\merge_sorted_array.cpp	/^int main()$/;"	f
main	.\n_queens.cpp	/^int main()$/;"	f
main	.\n_queens2.cpp	/^int main()$/;"	f
main	.\palidrome_partitioning.cpp	/^int main()$/;"	f
main	.\palidrome_partitioning2.cpp	/^int main()$/;"	f
main	.\populating_next_right_pointers_in_each_node.cpp	/^int main()$/;"	f
main	.\pow.cpp	/^int main()$/;"	f
main	.\remove_duplicates_from_sorted_list.cpp	/^int main()$/;"	f
main	.\remove_duplicates_from_sorted_list2.cpp	/^int main()$/;"	f
main	.\reorder_list.cpp	/^int main()$/;"	f
main	.\reverse_words_in_a_string.cpp	/^int main()$/;"	f
main	.\search_in_rotated_sorted.cpp	/^int main()$/;"	f
main	.\search_insert_position.cpp	/^int main()$/;"	f
main	.\single_number_1.cpp	/^int main()$/;"	f
main	.\single_number_2.cpp	/^int main()$/;"	f
main	.\sort_list.cpp	/^int main()$/;"	f
main	.\sqrt.cpp	/^int main()$/;"	f
main	.\sum_root_to_left_numbers.cpp	/^int main()$/;"	f
main	.\text_justification.cpp	/^int main()$/;"	f
main	.\two_sum.cpp	/^int main()$/;"	f
main	.\unique_path.cpp	/^int main()$/;"	f
main	.\valid_palindrome.cpp	/^int main()$/;"	f
main	.\wildcard_matching.cpp	/^int main()$/;"	f
main	.\word_break_1.cpp	/^int main()$/;"	f
main	.\word_break_2.cpp	/^int main()$/;"	f
max	.\binary_tree_maximum_path_sum.cpp	/^	int max(int a, int b){$/;"	f	class:Solution
max	.\maximum_subarray.cpp	/^	int max(const int &a, const int &b){$/;"	f	class:Solution
maxPathSum	.\binary_tree_maximum_path_sum.cpp	/^	int maxPathSum(TreeNode *root) {$/;"	f	class:Solution
maxPathSum	.\binary_tree_maximum_path_sum.cpp	/^	int maxPathSum(TreeNode *root, int &max_num){$/;"	f	class:Solution
maxPoints	.\max_points_on_a_line.cpp	/^	int maxPoints(vector<Point> &points) {$/;"	f	class:Solution
maxSubArray	.\maximum_subarray.cpp	/^	int maxSubArray(int A[], int n) {$/;"	f	class:Solution
max_iteration	.\max_points_on_a_line.cpp	/^	const int max_iteration = 20;$/;"	m	class:Solution	file:
merge	.\merge_sorted_array.cpp	/^	void merge(int A[], int m, int B[], int n) {$/;"	f	class:Solution
merge	.\sort_list.cpp	/^		ListNode *merge(ListNode *firstHead, ListNode *secondHead)$/;"	f	class:Solution
minCut	.\palidrome_partitioning2.cpp	/^	    int minCut(string s) {$/;"	f	class:Solution
neighbors	.\clone_graph.cpp	/^	vector<UndirectedGraphNode *> neighbors;$/;"	m	struct:UndirectedGraphNode	file:
next	.\copy_list_with_random_pointer.cpp	/^	RandomListNode *next, *random;$/;"	m	struct:RandomListNode	file:
next	.\insertion_sort_list.cpp	/^	ListNode *next;$/;"	m	struct:ListNode	file:
next	.\linked_list_cicle_1.cpp	/^	ListNode *next;$/;"	m	struct:ListNode	file:
next	.\linked_list_cicle_2.cpp	/^	ListNode *next;$/;"	m	struct:ListNode	file:
next	.\populating_next_right_pointers_in_each_node.cpp	/^	TreeLinkNode *left, *right, *next;$/;"	m	struct:TreeLinkNode	file:
next	.\remove_duplicates_from_sorted_list.cpp	/^    ListNode *next;$/;"	m	struct:ListNode	file:
next	.\remove_duplicates_from_sorted_list2.cpp	/^    ListNode *next;$/;"	m	struct:ListNode	file:
next	.\reorder_list.cpp	/^	ListNode *next;$/;"	m	struct:ListNode	file:
next	.\sort_list.cpp	/^	ListNode *next;$/;"	m	struct:ListNode	file:
node_map	.\copy_list_with_random_pointer.cpp	/^		unordered_map<int, RandomListNode *> node_map;$/;"	m	class:Solution	file:
non_DLR	.\binary_tree_maximum_path_sum.cpp	/^	void non_DLR(TreeNode *root){$/;"	f	class:Solution
non_LDR	.\binary_tree_maximum_path_sum.cpp	/^	void non_LDR(TreeNode *root){$/;"	f	class:Solution
non_LRD	.\binary_tree_maximum_path_sum.cpp	/^	void non_LRD(TreeNode *root){$/;"	f	class:Solution
numDistinct	.\distinct_subsequences.cpp	/^	int numDistinct(string S, string T) {$/;"	f	class:Solution
page_map	.\lru_cache.cpp	/^		unordered_map<int, list<pair<int, int>>::iterator> page_map;$/;"	m	class:LRUCache	file:
partition	.\first_missing_positive.cpp	/^               int partition(int A[], int lo, int hi) $/;"	f	class:Solution
partition	.\palidrome_partitioning.cpp	/^		vector<vector<string>> partition(string s) {$/;"	f	class:Solution
partition	.\two_sum.cpp	/^		int partition(vector<int> &numbers, int lo, int hi)$/;"	f	class:Solution
postorderTraversal	.\binary_tree_postorder_traversal.cpp	/^		vector<int> postorderTraversal(TreeNode *root) {$/;"	f	class:Solution
pow	.\pow.cpp	/^	double pow(double x, int n) {$/;"	f	class:Solution
preorderTraversal	.\binary_tree_preoorder_traversal.cpp	/^		vector<int> preorderTraversal(TreeNode *root) {$/;"	f	class:Solution
quick_sort	.\first_missing_positive.cpp	/^                void quick_sort(int A[],int lo, int hi) $/;"	f	class:Solution
quick_sort	.\two_sum.cpp	/^		void quick_sort(vector<int> &numbers, int lo, int hi)$/;"	f	class:Solution
random	.\copy_list_with_random_pointer.cpp	/^	RandomListNode *next, *random;$/;"	m	struct:RandomListNode	file:
reorderList	.\reorder_list.cpp	/^		void reorderList(ListNode *head) {$/;"	f	class:Solution
reverse	.\reorder_list.cpp	/^		ListNode *reverse(ListNode *head)$/;"	f	class:Solution
reverseWords	.\reverse_words_in_a_string.cpp	/^	void reverseWords(string &s){$/;"	f	class:Solution
right	.\binary_tree_maximum_path_sum.cpp	/^	TreeNode *right;$/;"	m	struct:TreeNode	file:
right	.\binary_tree_postorder_traversal.cpp	/^	TreeNode *right;$/;"	m	struct:TreeNode	file:
right	.\binary_tree_preoorder_traversal.cpp	/^	TreeNode *right;$/;"	m	struct:TreeNode	file:
right	.\construct_binary_tree.cpp	/^	TreeNode *right;$/;"	m	struct:TreeNode	file:
right	.\populating_next_right_pointers_in_each_node.cpp	/^	TreeLinkNode *left, *right, *next;$/;"	m	struct:TreeLinkNode	file:
right	.\sum_root_to_left_numbers.cpp	/^	TreeNode *right;$/;"	m	struct:TreeNode	file:
search	.\search_in_rotated_sorted.cpp	/^	int search(int A[], int begin, int end, const int &target){$/;"	f	class:Solution
search	.\search_in_rotated_sorted.cpp	/^    	int search(int A[], int n, int target) {$/;"	f	class:Solution
searchInsert	.\search_insert_position.cpp	/^	int searchInsert(int A[], int n, int target) {$/;"	f	class:Solution
set	.\lru_cache.cpp	/^		void set(int key, int value) {$/;"	f	class:LRUCache
show	.\candy.cpp	/^int show(vector<int> vec)$/;"	f
show	.\construct_binary_tree.cpp	/^		void show(TreeNode *root){$/;"	f	class:Solution
show	.\insertion_sort_list.cpp	/^void show(ListNode *head)$/;"	f
show	.\lru_cache.cpp	/^void show(list<pair<int, int>> virtual_page)$/;"	f
show	.\reorder_list.cpp	/^void show(ListNode *head)$/;"	f
show	.\sort_list.cpp	/^void show(ListNode *head)$/;"	f
show	.\two_sum.cpp	/^		void show(vector<int> numbers){$/;"	f	class:Solution
singleNumber	.\single_number_1.cpp	/^		int singleNumber(int A[], int n) {$/;"	f	class:Solution
singleNumber	.\single_number_2.cpp	/^		int singleNumber(int A[], int n) {$/;"	f	class:Solution
solveNQueens	.\n_queens.cpp	/^    	vector<vector<string> > solveNQueens(int n) {$/;"	f	class:Solution
sortList	.\sort_list.cpp	/^		ListNode *sortList(ListNode *head) {$/;"	f	class:Solution
sqrt	.\sqrt.cpp	/^		int sqrt(int x) {$/;"	f	class:Solution
start	.\insert_interval.cpp	/^	int start;$/;"	m	struct:Interval	file:
store_result	.\unique_path.cpp	/^	int store_result[101][101];$/;"	m	class:Solution	file:
subproblem	.\word_break_1.cpp	/^		unordered_set<string> subproblem;$/;"	m	class:Solution	file:
subproblem	.\word_break_2.cpp	/^		unordered_map<string, vector<string>> subproblem;$/;"	m	class:Solution	file:
sumNumbers	.\sum_root_to_left_numbers.cpp	/^	int sumNumbers(TreeNode *root) {$/;"	f	class:Solution
swap_int	.\single_number_1.cpp	/^		void swap_int(int A[], int a, int b)$/;"	f	class:Solution
swap_int	.\single_number_2.cpp	/^		void swap_int(int A[], int a, int b)$/;"	f	class:Solution
temp_result	.\pow.cpp	/^	map<int, double> temp_result;$/;"	m	class:Solution	file:
tolower	.\valid_palindrome.cpp	/^		void tolower(string &s){$/;"	f	class:Solution
totalNQueens	.\n_queens2.cpp	/^	int totalNQueens(int n) {$/;"	f	class:Solution
twoSum	.\two_sum.cpp	/^		vector<int> twoSum(vector<int> &numbers, int target) {$/;"	f	class:Solution
uniquePaths	.\unique_path.cpp	/^	int uniquePaths(int m, int n) {$/;"	f	class:Solution
val	.\binary_tree_maximum_path_sum.cpp	/^	int val;$/;"	m	struct:TreeNode	file:
val	.\binary_tree_postorder_traversal.cpp	/^	int val;$/;"	m	struct:TreeNode	file:
val	.\binary_tree_preoorder_traversal.cpp	/^	int val;$/;"	m	struct:TreeNode	file:
val	.\construct_binary_tree.cpp	/^	int val;$/;"	m	struct:TreeNode	file:
val	.\insertion_sort_list.cpp	/^	int val;$/;"	m	struct:ListNode	file:
val	.\linked_list_cicle_1.cpp	/^	int val;$/;"	m	struct:ListNode	file:
val	.\linked_list_cicle_2.cpp	/^	int val;$/;"	m	struct:ListNode	file:
val	.\populating_next_right_pointers_in_each_node.cpp	/^	int val;$/;"	m	struct:TreeLinkNode	file:
val	.\remove_duplicates_from_sorted_list.cpp	/^    int val;$/;"	m	struct:ListNode	file:
val	.\remove_duplicates_from_sorted_list2.cpp	/^    int val;$/;"	m	struct:ListNode	file:
val	.\reorder_list.cpp	/^	int val;$/;"	m	struct:ListNode	file:
val	.\sort_list.cpp	/^	int val;$/;"	m	struct:ListNode	file:
val	.\sum_root_to_left_numbers.cpp	/^	int val;$/;"	m	struct:TreeNode	file:
valid	.\generate_parentheses.cpp	/^	bool valid(vector<int> &cols, int &row, vector<int> &signal){$/;"	f	class:Solution
virtual_page	.\lru_cache.cpp	/^		list<pair<int, int>> virtual_page;$/;"	m	class:LRUCache	file:
wordBreak	.\word_break_1.cpp	/^		bool wordBreak(string s, unordered_set<string> &dict) {$/;"	f	class:Solution
wordBreak	.\word_break_2.cpp	/^		vector<string> wordBreak(string s, unordered_set<string> &dict) {$/;"	f	class:Solution
word_break	.\word_break_1.cpp	/^		bool word_break(string s, unordered_set<string> &dict, int max_dict_words)$/;"	f	class:Solution
word_break	.\word_break_2.cpp	/^		vector<string> word_break(string s, unordered_set<string> &dict)$/;"	f	class:Solution
x	.\max_points_on_a_line.cpp	/^     	int x;$/;"	m	struct:Point	file:
y	.\max_points_on_a_line.cpp	/^	int y;$/;"	m	struct:Point	file:
